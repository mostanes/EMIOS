\section{Security}
Computers have become an ubiquitous tool nowadays and are often used to process data at different security levels, using third party software. While for large enterprise software deployments this is easier to handle (by using multiple physically separate computers), in personal computing or home-office deployments, a single computer might need to work with external, untrusted data (for example websites), personal data (including private messages or identity documents) and possibly trade secrets or other confidential information. To prevent loss and leakage of such sensitive data, security must be thoroughly enforced even between pieces of software run by the same user. This can be achieved through per-application access control mechanisms (MAC, DAC and RBAC) and capability-based security. While access control can be enforced at kernel level, with great transparency to most applications, capability-based security requires deep integration with user software. Therefore, to effectively use CBS, a protocol for exchanging object tokens must exist between the applications.
\subsection{Fundamental concepts}
A list of relevant terms:
\begin{itemize}
	\item Physical user\\
	The user that is physically sitting at a terminal interacting with the computer (locally or remotely)
	\item Digital/OS user\\
	A digital representation of the physical user.
	\item Kernel Virtual User\\
	KVUs are a mechanism of mapping EMIOS users to POSIX users when the operating system does not does not provide sufficiently fine-grained security policies. In particular, a EMIOS user can have multiple POSIX users, but not vice-versa. These users isolate different pieces of software running on behalf of the same user. KVUs are a layer of abstraction that should be avoided, since they abstract away important user information from the lower levels of the operating system.
\end{itemize}
The hardware and software that a priori needs to be accepted as correct for the system to be considered secure is the Trusted Computing Base. For practical reasons, the TCB should be kept as small as possible.\\
For a computer system to work in a secure manner, it requires a set of secure paths, which are channels that cannot be intercepted (in the sense of reading or writing on the channel) by third parties (users or applications) running at the same security level or lower. These are critical for authentication, which must only be carried over secure paths.\\
\subsubsection{Security levels}
From the electrical signal travelling through a conductor to the third-party graphical app running on an operating system, there are many layers of abstraction. Each layer implements the abstractions of the layer above, thus it must necessarily be at a higher security level than the layers above. It is therefore trivial for such layers to intercept communication or perform even deeper changes to the layers above. There are practical reasons why this form of layering is even desirable -- testing, debugging, etc., require this ability. For this reason, secure paths are defined w.r.t. security levels, which are the groups of levels that have the same access to the information in the system.\\
These levels should not be fixed and should be transparent -- shifting the entire security stack up or down by one level should not change enforcement of policies. It must be possible to create "debug" policies on top of "normal" policies for the developers, with data and credentials stored in "debug" kept at a lower security level than "normal". For this reason, care must be taken against integrity compromises that allow "level injection" (malicious software running at security levels above the operating system).
\subsubsection{Shells and secure paths}
The user must be able to tell the system which resources should be accessible by which application. This is done through some user interface (be it TUI, with a path string, or via GUI, by selecting the resource from a list); this user interface, (part of) the shell, is part of the TCB. This shall be called Trusted Shell (particularly for distinction from SSH, secure shell, which is a remote shell protocol).\\
Users must communicate with the trusted shell over a secure path.
\subsection{CapSecAP: Capability-based Security Application Protocol}
\subsubsection{Tokens are resource descriptors}
Due to the everything-is-a-file policy of POSIX, it is possible to achieve capability-based security on POSIX (and compatible) systems through file descriptor passing. To preserve generality, we will refer to "resource descriptors" instead of "file descriptors"\footnote{For example, sockets cf. the definition of a file in the Oxford and Merriam-Webster dictionaries; therefore the term "resource" was chosen in this document as a more appropriate term. See also "Everything is an URL" in Redox.}.
\subsubsection{High level overview}
To not burden higher levels in the software stack or even the user with opening resource descriptors for each file touched by the software in question, access control policy must allow access to caches, common configuration files, etc., which fall under the scope of the software anyway.\\
Resource descriptors are passed by the trusted shell. In many instances, the resources that the program should open are already known by the shell (program arguments for command-line shells, selected resources for interactive shells). In the other case, the software must actively request access to a resource from the trusted shell. This must be done by either calling an executable that is not restricted by the access control mechanism (a concept similar to setuid), or by requesting the resource through the session bus.
\subsubsection{Descriptor passing through privileged child process}
The trusted shell resource opening helper must be called as "tshopen", which must be in the PATH environment variable. The software must send each file open request to the helper as three lines of text. The first line must contain the resource open arguments, which should be whitespace separated. The first argument should be whether to request opening of a specific resource or to request the user to select one. The second argument is the opening mode of the resource, read-only, write-only or read-write. Other optional arguments may be appended afterwards.\\
The second line contains the request to the user. This request text must be appropriately displayed by the trusted shell.\\
The third line contains the path to be opened. If a specific resource is requested from the user, this is the path to it. If the user is requested to select a resource, the software may suggest a path here, otherwise the line should be empty.\\
The standard output must be a unix domain socket. If the request is successful, the resource descriptor is passed through it. If the request in unsuccessful, a message must be sent on the standard output. It is recommended that the reason for denial be the message sent. Internal failure of the trusted shell should be reported through the standard error. It is recommended that software should restart the helper if output to the standard error has been detected and the process either crashed or exited without sending the resource descriptor or a message through the standard output.
\subsubsection{Descriptor passing through session bus}
The previous exchange may occur on the session bus, with the messages sent through the standard input and standard output replaced with messages sent on the session bus. Each request message must contain the full request; coalescing of message data from a sender is not required of the trusted shell.
TODO: Standardize a channel for resource open requests.
\subsection{Signatures}
Operating systems must provide support for signed software. All package contents must be hashed with a strong hash and the hashes must be signed. The hashes and package signatures must be available for checking, both manually and automatically. The program loader must check that the signatures are valid wherever they are available. The program loader must not run software with invalid signatures, unless explicitly allowed by the user.\\
Operating systems must support setting security policies on the signatures. It is strongly recommended that operating systems support at least multiple levels of trust for the signatures.\\
The TCB must be signed, and the signature must be of high enough trust. If the signature is found invalid during boot, the system must stop booting and display an appropriate error message. It is strongly recommended that operating systems include a recovery mode (using an alternate TCB, such as the last known good version).\\
The Trusted Shell must be able to pass the allowance of running software with invalid signatures to the program loader.